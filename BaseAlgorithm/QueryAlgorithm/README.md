# 查找算法分类：
  ### 静态查找和动态查找  
    1. 静态或者动态都是针对查找表而言的。  
    2. 动态表指查找表中有删除和插入操作的表。   
    
    
  ### 无序查找和有序查找  
    1. 无序查找：被查找数列有序无序均可；  
    2. 有序查找：被查找数列必须为有序数列。

  ### 指标  
    1. 平均查找长度（Average Search Length，ASL）：需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。   
    2. 对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。  
    3. Pi：查找表中第i个数据元素的概率。   
    4. Ci：找到第i个数据元素时已经比较过的次数。  

# SequenceSearch
### 顺序查找
  1. 核心:  
  
    1  顺序查找适合于存储结构为顺序存储或链接存储的线性表  
    2  顺序查找也称为线性查找，属于无序查找算法。  
    3  基本原理：从数据结构线性表的一端开始，顺序扫描，依次将扫描到的结点与查找值比较，若相等则表示查找成功；若扫描结束仍没有找到，表示查找失败。  
    4  时间复杂度：O(n)。     
    
# BinarySearch
### 二分查找
  1. 核心:  
  
    1  元素必须是有序的，如果是无序的则要先进行排序操作。 
    2  也称为是折半查找，属于有序查找算法。  
    3  基本原理：用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；
            若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。
    4  时间复杂度：O(log2n)。 
    
  2. 优化方法：  
    分为递归二分查找直接二分查找两种实现方法 


# InsertSearch
### 插值查找
  1. 核心:   查找点自适应的折分查找算法   
        
    1. 元素必须是有序的，如果是无序的则要先进行排序操作。
    2. 二分查找中查找点计算如下：mid=(low+high)/2, 即mid=low+1/2*(high-low);
    3. 通过类比，我们可以将查找的点改进为如下：mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，
    4. 基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。
       对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择
 
    5. 时间复杂度：
        O(log2(log2n))

# FibonacciSearch
### 斐波那契查找算法
   1. 核心：  
   
     1.  斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，
        在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n>=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）
     2. 斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，
        将原查找表扩展为长度为F[n](如果要补充元素，则补充重复最后一个元素，直到满足F[n]个元素)，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，
        后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。
     3. 斐波那契查找的时间复杂度还是O(log 2 n )，但是 与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，
     而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定。
       
# Binary Sort Tree Sarch
### 二叉树查找算法

    二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树
    1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
    2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
    3）任意节点的左、右子树也分别为二叉查找树。
    二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。
    它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡
    
### 红黑树

### B树，B+树
    B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。
    但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。
    B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中
    
    
# 分块查找
    分块查找又称索引顺序查找，它是顺序查找的一种改进方法。
    算法思想：
        将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……
    算法流程：
        step1 先选取各块中的最大关键字构成一个索引表；
        step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。
        
        
# 哈希查找
    哈希表是一个在时间和空间上做出权衡的经典例子。
    如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；
    如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。
    对于无冲突的Hash表而言，查找复杂度为O(1)