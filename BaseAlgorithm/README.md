# BubbleSort
### 冒泡排序，稳定排序,时间复杂度O（n^2）,空间复杂度O(1)
  1. 核心：相邻的比较；
  2. 优化方法：在内循环进行相邻的两个数据进行比较中，通过标记位，记录本次内循环是否发生了交换，如果没有发生交换，说明已经有序了，可以终止排序流程。

# SelectSort
### 快速排序，不稳定排序，时间复杂度O（n^2）,空间复杂度O(1)
  1. 核心：分成2个区，每次从待排序的数据中选择最小的放到已排序的最后一个
  2. 优化：如果最小值就是本值i,则不用本次不进行插入动作，否则进行插入动作

# InsertSort  & BinaryInsertSort
### 插入排序，稳定排序，时间复杂度O（n^2）,空间复杂度O(1)
  1. 核心：分成2个区，每次从待排序的数据中选择第一个i，插入签名i-1个数据中（比较& 最大 i-1个数据后移）
  2. 优化方法：针对第i个待插入到有序区域的数据，可以采用二分查找的方式从前i-1个位置找到i的位置，然后将第_index_left 到i-1的数剧都后移一位


# ShellSort
### 希尔排序，不稳定排序，时间复杂度O（n^2）,空间复杂度O(1)
  1. 核心：是按照增量递减的周期的插入排序，是插入排序的升级，主要充分利用了插入排序在基本有序的数据中线性的复杂度的特点
  2. 优化方法：

# QuickSort
### 快速排序，不稳定排序，平均时间复杂度O（nlogn）,最坏时间复杂度O（n^2）,空间复杂度O(logn)，最坏空间复杂度是O（n）,退化为冒泡排序
  1. 核心：分治的思想，找到摸一个基点，确保基点左边的都小于基点，基点右边的都大于右边的，然后递归处理基点的左分支和右分支
  2. 优化方法：
        基点的选择会对算法产生影响，可以选择中间数，随机数等

# MergeSort
### 归并排序，稳定排序，时间复杂度O（nlogn），空间复杂度为O(n)，缺点是占用二外的内存
  1. 核心：分治的思想，先把无序数据中间折半，分成左右两个子序对，再分解只到每个子序是剩下一个元素（有序），
        子序两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。
  2. 优化方法：



