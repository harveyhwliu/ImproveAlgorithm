# BubbleSort
### 冒泡排序，稳定排序,时间复杂度O（n^2）,空间复杂度O(1)
  1. 核心：相邻的比较；
  2. 优化方法：在内循环进行相邻的两个数据进行比较中，通过标记位，记录本次内循环是否发生了交换，如果没有发生交换，说明已经有序了，可以终止排序流程。

# SelectSort
### 快速排序，不稳定排序，时间复杂度O（n^2）,空间复杂度O(1)
  1. 核心：分成2个区，每次从待排序的数据中选择最小的放到已排序的最后一个
  2. 优化：如果最小值就是本值i,则不用本次不进行插入动作，否则进行插入动作

# InsertSort  & BinaryInsertSort
### 插入排序，稳定排序，时间复杂度O（n^2）,空间复杂度O(1)
  1. 核心：分成2个区，每次从待排序的数据中选择第一个i，插入签名i-1个数据中（比较& 最大 i-1个数据后移）
  2. 优化方法：针对第i个待插入到有序区域的数据，可以采用二分查找的方式从前i-1个位置找到i的位置，然后将第_index_left 到i-1的数剧都后移一位


# ShellSort
### 希尔排序，不稳定排序，时间复杂度O（n^2）,空间复杂度O(1)
  1. 核心：是按照增量递减的周期的插入排序，是插入排序的升级，主要充分利用了插入排序在基本有序的数据中线性的复杂度的特点
  2. 优化方法：

# QuickSort
### 快速排序，不稳定排序，平均时间复杂度O（nlogn）,最坏时间复杂度O（n^2）,空间复杂度O(logn)，最坏空间复杂度是O（n）,退化为冒泡排序
  1. 核心：分治的思想，找到摸一个基点，确保基点左边的都小于基点，基点右边的都大于右边的，然后递归处理基点的左分支和右分支
  2. 优化方法：
        基点的选择会对算法产生影响，可以选择中间数，随机数等

# MergeSort
### 归并排序，稳定排序，时间复杂度O（nlogn），空间复杂度为O(n)，缺点是占用二外的内存
  1. 核心：分治的思想，先把无序数据中间折半，分成左右两个子序对，再分解只到每个子序是剩下一个元素（有序），
        子序两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。
  2. 优化方法：

# HeapSort
### 堆排序，不稳定排序，时间复杂度O（nlogn），空间复杂度为O(1)
  1. 核心：堆即是一棵完全二叉树。堆排序的核心是堆调整算法。首先根据初始输入数据，利用堆调整算法shiftDown()形成最大堆；
            然后，将堆顶元素与堆尾元素交换，缩小堆的范围并重新调整为最大堆，如此往复。堆排序是一种不稳定的排序算法。
           最大堆：升序，最小堆降序
  2. 优化方法：

# CountingSort
### 计数排序，不稳定排序，时间复杂度O（N+k），空间复杂度为O(N+K)
  1. 核心：计数排序过程中不存在元素之间的比较和交换操作，根据元素本身的值，将每个元素出现的次数记录到辅助空间后，通过对辅助空间内数据的计算，即可确定每一个元素最终的位置。
    1-1. 申请空间，申请的额外空间大小为：序列中最大值 - 序列中最小值
    1-2. 将待排序集合中每一个元素 都记录到额外空间上，元素的索引值 index=元素值-序列值最小值，该索引对应的值，记录该元素出现的次数和。
  2. 优化方法：
    如果序列中极值大，则存在非常大的浪费，可以考虑使用桶排序


# BucketSort
### 桶排序，稳定排序，平均时间复杂度：O(n + k) 最佳时间复杂度：O(n + k) 最差时间复杂度：O(n ^ 2)  空间复杂度：O(n * k)
   1. 核心：每个桶都是一个有序链表，桶排序就是先把数据有序的插入到每个桶里面，然后遍历所有的桶，把数据取出来
     1-1. 设置一个定量的数组当作空桶子。
     1-2. 寻访序列，并且把项目一个一个放到对应的桶子去。
     1-3. 对每个不是空的桶子进行排序。
     1-4. 从不是空的桶子里把项目再放回原来的序列中。
  2. 优化方法：

# RadixSort
### 基数排序，桶排序的升级版
  1. 核心：
  2. 优化方法：

